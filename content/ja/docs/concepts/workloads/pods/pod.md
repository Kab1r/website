---
reviewers:
title: Pod
content_template: templates/concept
weight: 20
---

{{% capture overview %}}

_Pod_ は、Kubernetes で作成および管理できる、デプロイ可能な最小のコンピューティ
ング単位です。

{{% /capture %}}

{{% capture body %}}

## Pod とは

_Pod_ は（クジラの小群やエンドウ豆のさやのように）、共有のストレージ/ネットワー
クを持つ 1 つ以上のコンテナ（例えば Docker コンテナ）、およびコンテナを実行する
方法についての仕様です。Pod 内のコンテナ群は常に同じ場所に配置され、協調してスケ
ジューリングされ、共通のコンテキストで実行されます。Pod は、アプリケーション固有
の「論理ホスト」――やや密に結合した 1 つ以上のアプリケーション・コンテナを含むも
の――をモデル化します。コンテナ以前の世界では、同じ物理または仮想マシン上で実行さ
れることが、同じ論理ホスト上で実行されることを意味するでしょう。

Kubernetes は、Docker だけでなくより多くのコンテナ・ランタイムをサポートしていま
すが、Docker は最もよく知られているランタイムであり、Docker の用語を使って Pod
を説明することが可能です。

Pod 内では、Linux namespace や cgroup などの Docker コンテナを分離する一連の要
と同じものがコンテキストとして共有されます。 Pod のコンテキスト内で、個々のアプ
リケーションに更なる分離が適用されることがあります。

Pod 内のコンテナは IP アドレスとポートの空間を共有し、 `localhost` を通じてお互
いを見つけることができます 。また、SystemV セマフォや POSIX 共有メモリなどの標準
のプロセス間通信（IPC）を使用して互いに通信することもできます。異なる Pod のコン
テナは異なる IP アドレスを持ち
、[特別な設定](/docs/concepts/policy/pod-security-policy/)がなければ IPC では通
信できません。これらのコンテナは通常、Pod IP アドレスを介して互いに通信します。

Pod 内のアプリケーションからアクセスできる共有ボリュームを、Pod の一部として定義
できます。このボリュームは個々のアプリケーションのファイルシステムにマウント可能
です。

[Docker](https://www.docker.com/)の用語でいえば、Pod は共有 namespace と共
有[ボリューム](/docs/concepts/storage/volumes/)を持つ Docker コンテナのグループ
としてモデル化されています。

個々のアプリケーションコンテナと同様に、Pod は（永続的ではなく）比較的短期間の存
在と捉えられます。
[Pod のライフサイクル](/docs/concepts/workloads/pods/pod-lifecycle/)で説明してい
るように、Pod が作成されると、一意の ID（UID）が割り当てられ、（再起動ポリシーに
従って）終了または削除されるまで Node で実行されるようにスケジュールされます。
Node が停止した場合、その Node にスケジュールされた Pod は、タイムアウト時間の経
過後に削除されます。特定の Pod（UID で定義）は新しい Node に「再スケジュール」さ
れません。代わりに、必要に応じて同じ名前で、新しい UID を持つ同一の Pod に置き換
えることができます（詳細について
は[ReplicationController](/docs/concepts/workloads/controllers/replicationcontroller/)を
参照してください）。

ボリュームなど、Pod と同じ存続期間を持つものがあると言われる場合、それは（その
UID を持つ）Pod が存在する限り存在することを意味します。その Pod が何らかの理由
で削除された場合、たとえ同じ代替物が作成されたとしても、関連するもの（例えばボリ
ューム）も同様に破壊されて再作成されます。

{{< figure src="/images/docs/pod.svg" title="Podの図" width="50%" >}}

_file puller（ファイル取得コンテナ）と Web サーバーを含むマルチコンテナの Pod。
コンテナ間の共有ストレージとして永続ボリュームを使用している。_

## Pod を用いる動機

### 管理

Pod は、まとまったサービスの単位を形成する複数の協調プロセスのパターンをモデル化
したものです。構成要素であるアプリケーションの集まりよりも高いレベルの抽象化を提
供することによって、アプリケーションのデプロイと管理を単純化します。 Pod は、デ
プロイや水平スケーリング、レプリケーションの単位として機能します。 Pod 内のコン
テナに対しては、同じ場所への配置（共同スケジューリング）、命運の共有（つまり停止
）、協調レプリケーション、リソース共有や依存関係の管理が自動的に取り扱われます。

### リソース共有と通信

Pod は、構成要素間でのデータ共有および通信を可能にします。

Pod 内のアプリケーションはすべて同じネットワーク名前空間（同じ IP およびポートス
ペース）を使用するため、 `localhost` としてお互いを「見つけて」通信できます。こ
のため、Pod 内のアプリケーションはそれぞれ使用するポートを調整する必要があります
。各 Pod は、他の物理コンピュータや Pod と自由に通信するためのフラットな共有ネッ
トワーク空間上に IP アドレスを持ちます。

Pod 内のアプリケーションコンテナのホスト名には、Pod の名前が設定されます。詳細
は[クラスターネットワーク](/docs/concepts/cluster-administration/networking/)を
ご覧ください。

Pod で実行されるアプリケーションコンテナの定義に加えて、Pod によって共有ストレー
ジであるボリュームを複数設定することも可能です。ボリュームを使用すると、データは
コンテナの再起動後も存続し、Pod 内のアプリケーション間で共有できます。

## Pod の用途

Pod は、垂直に統合されたアプリケーションスタック（例：LAMP）をホストするために使
用できます。しかし、Pod を使う主な動機は、次のように同じ場所に配置され、共に管理
されるヘルパープログラムをサポートすることです。

- コンテンツ管理システム(CMS)、ファイルやデータのローダー、ローカルのキャッシュ
  マネージャーなど
- ログとチェックポイントのバックアップ、圧縮、ローテーション、スナップショットな
  ど
- データの変更を監視するもの、ログを tail するもの、ロギングおよび監視の補助プロ
  グラム、イベントを発行するものなど
- プロキシ、ブリッジ、およびアダプタ
- コントローラー、マネージャー、コンフィギュレーター、およびアップデーター

個々の Pod は、一般に、同じアプリケーションの複数のインスタンスを実行することを
目的としていません。

詳細については
、[The Distributed System ToolKit: Patterns for Composite Containers](https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns)（
分散システムツールキット：複合コンテナのパターン）を参照してください。

## 考えられる代替案

_単一の（Docker）コンテナで複数のプログラムを実行しないのはなぜですか？_

1. 透明性のため。Pod 内のコンテナをインフラストラクチャから見えるようにすること
   で、インフラストラクチャはプロセス管理やリソース監視などのサービスをコンテナ
   に提供できます。これは、ユーザーに多くの便益を提供します。
1. ソフトウェアの依存関係を減らすため。個々のコンテナは、独立してバージョン管理
   、再構築、および再デプロイできます。 Kubernetes はいつか個々のコンテナのライ
   ブアップデートをサポートするかもしれません。
1. 使いやすさのため。ユーザーは独自のプロセスマネージャーを実行する必要はありま
   せん。シグナルや終了コードの伝播などについて心配する必要はありません。
1. 効率のため。インフラストラクチャがより責任を負うため、コンテナはより軽量にな
   ります。

_アフィニティ（結合性、親和性）ベースのコンテナの共同スケジューリングをサポート
しないのはなぜですか？_

このアプローチによって、コンテナの共同配置は提供されるでしょう。しかし、リソース
共有や IPC、保証された命運の共有、および簡素化された管理といった Pod の利点のほ
とんどは提供されないでしょう。

## Pod の耐久性（またはその欠如）

Pod は、耐久性のある存在として扱われることを意図していません。スケジューリングの
失敗や、Node の故障には耐えられません。リソースの不足や Node のメンテナンスとい
った場合に、追い出されて停止することもあり得ます。

一般に、ユーザーは Pod を直接作成する必要はありません。ほとんどの場合、対象がシ
ングルトンであったとしても
、[Deployments](/ja/docs/concepts/workloads/controllers/deployment/)などのコント
ローラーを使用するべきです。コントローラーは、レプリケーションとロールアウト管理
だけでなく、クラスターレベルの自己修復機能も提供します。
[StatefulSet](/ja/docs/concepts/workloads/controllers/statefulset.md)ようなコン
トローラーもステートフルな Pod をサポートします。

主要なユーザー向けのプリミティブとして集合 API を使用することは
、[Borg](https://research.google.com/pubs/pub43438.html)、
[Marathon](https://mesosphere.github.io/marathon/docs/rest-api.html)、[Aurora](http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema)、[Tupperware](http://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997)な
どのクラスタースケジューリングシステムで比較的一般的です。

Pod は、以下のことを容易にするためにプリミティブとして公開されています。

- スケジューラーとコントローラーをプラガブルにする
- コントローラー API を介して「プロキシ」の必要なしに、Pod レベルの操作をサポー
  トする
- ブートストラップなどのために、コントローラーの寿命から Pod の寿命を切り離す
- コントローラーとサービスを分離する――エンドポイントコントローラーは Pod のみを
  監視する
- Kubelet レベルの機能とクラスターレベルの機能をきれいに組み合わせる――Kubelet は
  事実上「Pod コントローラー」となる
- アプリケーションの可用性を高める。即ち、計画的な追い出しやイメージのプリフェッ
  チなどの場合に、Pod が停止し削除される前に、必ず事前に入れ換えられることを期待
  する

## Pod の終了

Pod は、クラスター内の Node で実行中のプロセスを表すため、不要になったときにそれ
らのプロセスを正常に終了できるようにすることが重要です（対照的なケースは、KILL
シグナルで強制終了され、クリーンアップする機会がない場合）。ユーザーは削除を要求
可能であるべきで、プロセスがいつ終了するかを知ることができなければなりませんが、
削除が最終的に完了することも保証できるべきです。ユーザーが Pod の削除を要求する
と、システムは Pod が強制終了される前に意図された猶予期間を記録し、各コンテナの
メインプロセスに TERM シグナルが送信されます。猶予期間が終了すると、プロセスに
KILL シグナルが送信され、Pod は API サーバーから削除されます。プロセスの終了を待
っている間に Kubelet かコンテナマネージャーが再起動されると、終了処理は猶予期間
の後にリトライされます。

フローの例は下のようになります。

1. ユーザーがデフォルトの猶予期間（30 秒）で Pod を削除するコマンドを送信する
1. API サーバー内の Pod は、猶予期間を越えると Pod が「死んでいる」と見なされる
   ように更新される
1. クライアントのコマンドに表示されたとき、Pod は「終了中」と表示される
1. （3 と同時に）Kubelet は、2 の期間が設定されたために Pod が終了中となったこと
   を認識すると、Pod のシャットダウン処理を開始する
   1. Pod 内のコンテナの 1 つ
      が[preStop フック](/docs/concepts/containers/container-lifecycle-hooks/#hook-details)を
      定義している場合は、コンテナの内側で呼び出される。猶予期間が終了した後も
      `preStop` フックがまだ実行されている場合は、次に、短い延長された猶予期間
      （2 秒）でステップ 2 が呼び出される
   1. コンテナに TERM シグナルが送信される。Pod 内のすべてのコンテナが同時に
      TERM シグナルを受信するわけではなく、シャットダウンの順序が問題になる場合
      はそれぞれに `preStop` フックが必要になることがある
1. （3 と同時に）Pod はサービスを提供するエンドポイントのリストから削除され
   、ReplicationController の実行中の Pod の一部とは見なされなくなる。ゆっくりと
   シャットダウンする Pod は、（サービスプロキシのような）ロードバランサーがロー
   テーションからそれらを削除するので、トラフィックを処理し続けることはできない
1. 猶予期間が終了すると、Pod 内でまだ実行中のプロセスは SIGKILL で強制終了される
1. Kubelet は猶予期間を 0（即時削除）に設定することで API サーバー上の Pod の削
   除を終了する。 Pod は API から消え、クライアントからは見えなくなる

デフォルトでは、すべての削除は 30 秒以内に正常に行われます。 `kubectl delete` コ
マンドは、ユーザーがデフォルト値を上書きして独自の値を指定できるようにする
`--grace-period=<seconds>` オプションをサポートします。値 `0` は Pod
を[強制的に削除](/ja/docs/concepts/workloads/pods/pod/#podの強制削除)します。
kubectl のバージョン 1.5 以降では、強制削除を実行するために `--grace-period=0`
と共に `--force` というフラグを追加で指定する必要があります。

### Pod の強制削除

Pod の強制削除は、クラスターの状態や etcd から Pod を直ちに削除することと定義さ
れます。強制削除が実行されると、apiserver は、Pod が実行されていた Node 上で Pod
が停止されたという kubelet からの確認を待ちません。 API 内の Pod は直ちに削除さ
れるため、新しい Pod を同じ名前で作成できるようになります。 Node 上では、すぐに
終了するように設定される Pod は、強制終了される前にわずかな猶予期間が与えられま
す。

強制削除は、Pod によっては潜在的に危険な場合があるため、慎重に実行する必要があり
ます。 StatefulSet の Pod については
、[StatefulSet から Pod を削除するためのタスクのドキュメント](/docs/tasks/run-application/force-delete-stateful-set-pod/)を
参照してください。

## Pod コンテナの特権モード

Kubernetes v1.1 以降、Pod 内のどのコンテナでも、コンテナ仕様の `SecurityContext`
の `privileged` フラグを使用して特権モードを有効にできます。これは、ネットワーク
スタックの操作やデバイスへのアクセスなど、Linux の機能を使用したいコンテナにとっ
て役立ちます。コンテナ内のプロセスは、コンテナ外のプロセスで利用できるものとほぼ
同じ特権を獲得します。特権モードでは、ネットワークプラグインとボリュームプラグイ
ンを別々の Pod として作成する方が簡単なはずです。それらを kubelet にコンパイルす
る必要はありません。

マスターが Kubernetes v1.1 以降を実行しており、Node が v1.1 より前のバージョンを
実行している場合、新しい特権付きの Pod は API サーバーに受け入れられますが、起動
されません。それらは保留状態になります。ユーザーが
`kubectl describe pod FooPodName` を実行すると、Pod が保留状態になっている理由を
確認できます。 describe コマンド出力のイベントテーブルには、次のように表示されま
す。
`Error validating pod "FooPodName"."FooPodNamespace" from api, ignoring: spec.containers[0].securityContext.privileged: forbidden '<*>(0xc2089d3248)true'`

マスターが v1.1 より前のバージョンを実行している場合、特権を持つ Pod は作成でき
ません。ユーザーが特権付きのコンテナを含む Pod を作成しようとすると、次のエラー
を受け取ります。
`The Pod "FooPodName" is invalid. spec.containers[0].securityContext.privileged: forbidden '<*>(0xc20b222db0)true'`

## API オブジェクト

Pod は Kubernetes REST API のトップレベルのリソースです。 API オブジェクトの詳細
については、[Pod API
オブジェクト](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#pod-v1-core)
を参照してください 。

{{% /capture %}}
